<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>config/sockets.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/:: Controller.html">:: Controller</a></li>
            
                <li><a href="../modules/:: Model.html">:: Model</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: config/sockets.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * Socket Configuration
 *
 * These configuration options provide transparent access to Sails&#x27; encapsulated
 * pubsub/socket server for complete customizability.
 *
 * For more information on using Sails with Sockets, check out:
 * http://sailsjs.org/#documentation
 */

module.exports.sockets = {

	// &#x60;transports&#x60;
	//
	// A array of allowed transport methods which the clients will try to use.
	// The flashsocket transport is disabled by default
	// You can enable flashsockets by adding &#x27;flashsocket&#x27; to this list:
	transports: [
		&#x27;websocket&#x27;,
		&#x27;htmlfile&#x27;,
		&#x27;xhr-polling&#x27;,
		&#x27;jsonp-polling&#x27;
	],

	// &#x60;adapter&#x60;
	//
	// Node.js (and consequently Sails.js) apps scale horizontally.
	// It&#x27;s a powerful, efficient approach, but it involves a tiny bit of planning.
	// At scale, you&#x27;ll want to be able to copy your app onto multiple Sails.js servers
	// and throw them behind a load balancer.
	//
	// One of the big challenges of scaling an application is that these sorts of clustered 
	// deployments cannot share memory, since they are on physically different machines.
	// On top of that, there is no guarantee that a user will &quot;stick&quot; with the same server between
	// requests, since the load balancer will route each request to the server with the 
	// least impact on load. All pubsub processing and shared memory has to be offloaded
	// to a shared, remote messaging queue (usually Redis)
	//
	// Luckily, Sails provides production MQ support for Redis by default!
	//
	// The data store where socket.io will store its message queue 
	// and answer pubsub logic
	// adapter: &#x27;memory&#x27;,
	//
	// To enable a remote redis pubsub server: 
	adapter: &#x27;redis&#x27;,
	host: &#x27;localhost&#x27;,
	port: 6379,
	ttl: 15,
	db: 1,
	// pass: &#x27;confManager&#x27;,
	prefix: &#x27;socket:&#x27;,
	// Worth mentioning is that, if &#x60;adapter&#x60; config is &#x60;redis&#x60;, 
	// but host/port is left unset, Sails will try to connect to redis 
	// running on localhost via port 6379 

	// &#x60;authorization&#x60;
	//
	// Global authorization for Socket.IO access, 
	// this is called when the initial handshake is performed with the server.
	// 
	// By default (&#x60;authorization: true&#x60;), when a socket tries to connect, Sails verifies
	// that a valid cookie was sent with the upgrade request.  If the cookie doesn&#x27;t match
	// any known user session, a new user session is created for it.
	//
	// However, in the case of cross-domain requests, it is possible to receive a connection
	// upgrade request WITHOUT A COOKIE (for certain transports)
	// In this case, there is no way to keep track of the requesting user between requests,
	// since there is no identifying information to link him/her with a session.
	//
	// If you don&#x27;t care about keeping track of your socket users between requests,
	// you can bypass this cookie check by setting &#x60;authorization: false&#x60;
	// which will disable the session for socket requests (req.session is still accessible 
	// in each request, but it will be empty, and any changes to it will not be persisted)
	//
	// On the other hand, if you DO need to keep track of user sessions, 
	// you can pass along a ?cookie query parameter to the upgrade url, 
	// which Sails will use in the absense of a proper cookie
	// e.g. (when connection from the client):
	// io.connect(&#x27;http://localhost:1337?cookie=smokeybear&#x27;)
	//
	// (Un)fortunately, the user&#x27;s cookie is (should!) not accessible in client-side js.
	// Using HTTP-only cookies is crucial for your app&#x27;s security.
	// Primarily because of this situation, as well as a handful of other advanced
	// use cases, Sails allows you to override the authorization behavior 
	// with your own custom logic by specifying a function, e.g:
	/*
    authorization: function authorizeAttemptedSocketConnection(reqObj, cb) {

        // Any data saved in &#x60;handshake&#x60; is available in subsequent requests
        // from this as &#x60;req.socket.handshake.*&#x60;

        //
        // to allow the connection, call &#x60;cb(null, true)&#x60;
        // to prevent the connection, call &#x60;cb(null, false)&#x60;
        // to report an error, call &#x60;cb(err)&#x60;
    }
  */
	authorization: true,

	// Match string representing the origins that are allowed to connect to the Socket.IO server
	origins: &#x27;*:*&#x27;,

	// Should we use heartbeats to check the health of Socket.IO connections?
	heartbeats: true,

	// When client closes connection, the # of seconds to wait before attempting a reconnect.
	// This value is sent to the client after a successful handshake.
	&#x27;close timeout&#x27;: 60,

	// The # of seconds between heartbeats sent from the client to the server
	// This value is sent to the client after a successful handshake.
	&#x27;heartbeat timeout&#x27;: 60,

	// The max # of seconds to wait for an expcted heartbeat before declaring the pipe broken
	// This number should be less than the &#x60;heartbeat timeout&#x60;
	&#x27;heartbeat interval&#x27;: 25,

	// The maximum duration of one HTTP poll-
	// if it exceeds this limit it will be closed.
	&#x27;polling duration&#x27;: 20,

	// Enable the flash policy server if the flashsocket transport is enabled
	// &#x27;flash policy server&#x27;: true,

	// By default the Socket.IO client will check port 10843 on your server 
	// to see if flashsocket connections are allowed.
	// The Adobe Flash Player normally uses 843 as default port, 
	// but Socket.io defaults to a non root port (10843) by default
	//
	// If you are using a hosting provider that doesn&#x27;t allow you to start servers
	// other than on port 80 or the provided port, and you still want to support flashsockets 
	// you can set the &#x60;flash policy port&#x60; to -1
	&#x27;flash policy port&#x27;: 10843,

	// Used by the HTTP transports. The Socket.IO server buffers HTTP request bodies up to this limit. 
	// This limit is not applied to websocket or flashsockets.
	&#x27;destroy buffer size&#x27;: &#x27;10E7&#x27;,

	// Do we need to destroy non-socket.io upgrade requests?
	&#x27;destroy upgrade&#x27;: true,

	// Should Sails/Socket.io serve the &#x60;socket.io.js&#x60; client? 
	// (as well as WebSocketMain.swf for Flash sockets, etc.)
	&#x27;browser client&#x27;: true,

	// Cache the Socket.IO file generation in the memory of the process
	// to speed up the serving of the static files.
	&#x27;browser client cache&#x27;: true,

	// Does Socket.IO need to send a minified build of the static client script?
	&#x27;browser client minification&#x27;: false,

	// Does Socket.IO need to send an ETag header for the static requests?
	&#x27;browser client etag&#x27;: false,

	// Adds a Cache-Control: private, x-gzip-ok=&quot;&quot;, max-age=31536000 header to static requests, 
	// but only if the file is requested with a version number like /socket.io/socket.io.v0.9.9.js.
	&#x27;browser client expires&#x27;: 315360000,

	// Does Socket.IO need to GZIP the static files?
	// This process is only done once and the computed output is stored in memory. 
	// So we don&#x27;t have to spawn a gzip process for each request.
	&#x27;browser client gzip&#x27;: false,

	// Optional override function to serve all static files, 
	// including socket.io.js et al.
	// Of the form :: function (req, res) { /* serve files */ }
	&#x27;browser client handler&#x27;: false,

	// Meant to be used when running socket.io behind a proxy. 
	// Should be set to true when you want the location handshake to match the protocol of the origin. 
	// This fixes issues with terminating the SSL in front of Node 
	// and forcing location to think it&#x27;s wss instead of ws.
	&#x27;match origin protocol&#x27;: false,

	// Direct access to the socket.io MQ store config
	// The &#x27;adapter&#x27; property is the preferred method
	// (&#x60;undefined&#x60; indicates that Sails should defer to the &#x27;adapter&#x27; config)
	store: undefined,

	// A logger instance that is used to output log information.
	// (&#x60;undefined&#x60; indicates deferment to the main Sails log config)
	logger: undefined,

	// The amount of detail that the server should output to the logger.
	// (&#x60;undefined&#x60; indicates deferment to the main Sails log config)
	&#x27;log level&#x27;: undefined,

	// Whether to color the log type when output to the logger.
	// (&#x60;undefined&#x60; indicates deferment to the main Sails log config)
	&#x27;log colors&#x27;: undefined,

	// A Static instance that is used to serve the socket.io client and its dependencies.
	// (&#x60;undefined&#x60; indicates use default)
	&#x27;static&#x27;: undefined,

	// The entry point where Socket.IO starts looking for incoming connections. 
	// This should be the same between the client and the server.
	resource: &#x27;/socket.io&#x27;

};
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
